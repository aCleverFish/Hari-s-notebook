# 统一建模语言UML

## 1.面向对象以及软件建模的基本概念

​	**软件开发的现状：**

- 大规模，复杂化
- 开发周期短
- 国际竞争
- 业务系统和嵌入式系统的相互融合

​	**软件开发的课题：**

- 质量
- 成本
- 工期
- 生产性

​	**面向对象的有效性**：

- 能够从用户的角度来分析系统
- 用户和开发人员之间能够很方便地进行交流
- 应对需求变化的能力强（封装）
- ==使系统变得更容易理解，提高代码的可复用性和系统的可维护性==（泛化、封装）

**面向对象的基本概念**：

###对象和类

- 对象：

  对象是物理上或概念上存在的物体、人或事情

​	   分析阶段的对象一般是指客观世界中存在的物体（如电视、狗、人）

​	   有时也包括一些抽象的事物（如合同、销售额等）

​	   对象具有属性和行为

​	   对象具有状态

​	   对象具有唯一可识别性

- 类：

  类是着眼于对象的属性和行为的共通性，进行抽象化之后形成的

  对象是类实例化之后形成的

###消息传递

​	在面向对象系统中，对象之间是通过消息的发送和接收来促进处理向前进行的

​	接收消息的一方的对象，要对接收到的消息做出反应。也就是要在对象的操作中定义消息反应的行为

![01](E:\笔记\UML语言\01.png)

​	==消息的传递是通过对象的方法进行传递的==

###封装

- 信息封装：

  ​	信息封装也称为信息隐藏

  ​	不想让外界直接访问的信息，可以通过公开给外部的接口，让其进行访问，可以保护对象内部的数据

- 信息封装的优点：

  ​	对于使用方法来讲，不关心内部，只要知道接口的调用方法即可获得所需要的信息

  ​	对于被使用方法来讲，只要不改变接口，就可以随意进行内部修改。可以实现内部信息的安全性

###泛化

​	**泛化用来表示类的层次关系**

​		超类和子类之间的分类关系

​		子类和超类之间的继承关系

​			子类能继承超类的特性（属性、操作、关系）

​			子类还能追加超类所没有的新特性

​			子类还能重新定义超类继承下来的操作

​	**创建泛化的方法**

​		创建超类

​			着眼于若干个类的共性，创建具有共性的超类

​			是自下而上地创建继承关系

​		创建子类

​			以共性为基础，创建具有新特性的子类

​			子类还能追加超类所没有的新特性

​			自上而下地创建继承层次关系

​	**泛化的有效性**

​		在系统开发中使用泛化，具有以下优点：

​			概念被体系化，系统变得更加容易理解

​			通过继承现存的类来定义新的类，可以使源代码得到复用，提高生产效率，提高系统的可维护性

![02](E:\笔记\UML语言\02.png)

###多态性

​		对于相同的消息，接收到这个消息的对象可以用各自不同的处理办法来处理

​		只要接口不变，即使对象的种类增加了，也不需要修改调用方的程序。增强了应对需求变化的能力

​		强制类型转化就是一种多态

​		一个类中的重载，是实现多态的一种方法，调同一种方法，产生了不同的效果，目的就是为了扩展方便

​		**抽象类**

​		具有属性和操作，但是仅仅只是表示概念的定义，不能实例化为对象的类

​		肯定存在子类

​		类名用斜体字来表示

![03](E:\笔记\UML语言\03.png)

##2.**模型**和建模的基本概念

​	把复杂的现实世界按照某种特定目的来进行抽象化、简单化、形式化之后形成的

​	根据接受消息一方的世界观，对于所要传达的信息进行过滤，只表现需要强调的部分

​	**建模**

​	针对各个开发阶段可以进行如下的建模工作

​		业务建模：对对象领域的业务流进行建模设计（产品经理）

​		要求分析建模：对系统的要求进行建模（用例图）

​		分析建模：站在用户角度来对系统对象领域进行表示

​		设计建模：对如何实现系统进行表示

![04](E:\笔记\UML语言\04.png)

​		实现建模：考虑系统运行时的硬件环境，表示系统的物理侧面

![05](E:\笔记\UML语言\05.png)



真正的coding阶段只占整个项目的1/6

**开发过程**

- 定义系统开发的各个阶段的成果物，各个参与人员的职责，以及开发流程
- 开发流程的组成元素
  - 各个开发人员和整个开发组所要做的工作内容
  - 工作顺序
  - 各个开发阶段的成果物的定义和雏形
  - 开发活动管理
- 开发过程的例子
  - 瀑布型开发
  - 迭代型开发
  - 螺旋型开发
  - 敏捷型开发

##3.UML的基本概念

​	==找到一个合适的解决方案就可以了，一定不要考虑过多的细节==

​	统一建模语言UML（Unified Modelling Language）

​	有OMG（Object Management Group）软件标准化组织进行统一标准化

​	仅仅是一种描述语言，规定了一些表示方法，和具体的开发语言以及开发过程没有任何关系

| 类型       | 图名       | 概要说明                                                     |
| ---------- | ---------- | ------------------------------------------------------------ |
| 静态结构图 | ==类图==   | 表示分析设计领域的静态结构（表关系）                         |
|            | 对象       | 表示系统中的多个对象在某一时刻的状态                         |
|            | 包图       | 对UML的模型元素进行分组整理，还可以表示多个包之间的关系      |
|            | ==构建图== | 表示构成软件的各个可重复再利用的部件的内部结构以及部件之间的相互关系 |
|            | 组合结构图 | 表示具有复杂内部结构的类或这构件的内部结构                   |
|            | ==部署图== | 表示系统执行时的硬件构成以及硬件节点之间的关系               |
|            |            |                                                              |
| 动态行为图 | ==用例图== | 表示从系统外部部署看到的系统所提供给用户可以使用的功能       |
|            | 活动图     | 表示某个业务的具体处理流程，或者程序的某个算法               |
|            | ==顺序图== | 按照时间顺序从上到下来表示生命线之间的消息交互，可结合用例图表示某个用例的场景 |
|            | 通信图     | 以参与交互的生命线之间的连接为着眼点表示生命线之间的消息交互 |
|            | 交互概览图 | 用活动图的形式表示多个交互之间的控制关系                     |
|            | 时序图     | 表示多个生命线的状态变化和时间之间的关系                     |
|            | ==状态图== | 表示某个对象在其生命周期内，各个状态之间的迁移变化及引起状体迁移的触发事件之间的关系 |

从需求到分析到设计，提高我们通用能力的一个方法

![06](E:\笔记\UML语言\06.png)





![07](E:\笔记\UML语言\07.png)

E-R图（对应集中式数据库会比较好）逐步被类图所取代,因为类图有属性、操作、方法

E-R图主要针对一些关系型数据库

而现在越来越多的NOSQL数据库（非关系型数据库）

![09](E:\笔记\UML语言\09.png)

![10](E:\笔记\UML语言\10.png)





![08](E:\笔记\UML语言\08.png)

我们仅仅有用例是不够的，我们不知道这个检索书籍怎么完成的

所以我们就需要用时序图对我们的用例进行说明



![11](E:\笔记\UML语言\11.png)

对检索图书名进行一个描述

![12](E:\笔记\UML语言\12.png)

可以类比进程的七种状态

画一个对象的状态图，可以把这对象的状态全部列出来

![13](E:\笔记\UML语言\13.png)

一个方框代表一个泳道，一个泳道就代表一个对象的生命周期

在这个横线的时候，就开始异步了

当所有条件满足时，同步然后再回来

![14](E:\笔记\UML语言\14.png)



![15](D:\学习资料\UML建模语言\15.png)

![17](E:\笔记\UML语言\17.png)



![16](E:\笔记\UML语言\16.png)





## 4.用例图的概要

产品经理：站在用户的角度描述用户对系统的需求

用例图的组成要素：

- 参与者
- 用例
- 关联
- 系统边界

![01](E:\笔记\UML语言用例图\01.png)



在系统开发的初期阶段把握用户需求时使用，便于用户和系统开发者之间进行意向沟通

从动态的侧面来描述系统给用户可使用的功能

在分析设计阶段，以用例图为基础，来做成其他UML图形（如顺序图、通信图、类图等）

==通常，我们在和用户采集需求建模的时候，用户也不知道自己想要什么==

用什么方法让用户说出想法？

参与者应该是一句话的主语

用例是动宾短语

（主、谓、宾）尽量引导出：谁干什么事情

  一定要清楚边界在什么地方，要干什么不干什么，边界越清晰系统的成功率越高

 明确：谁用这个系统，要干什么事情

###参与者的例子

- 参与者是使用者

  ![02](E:\笔记\UML语言用例图\02.png)

- 参与者是外部硬件

  ![03](E:\笔记\UML语言用例图\03.png)

- 参与者是现有系统

![04](E:\笔记\UML语言用例图\04.png)

###用例和用例之间的关系

泛化

​	一个用例的流程默认情况下总是被另一个用例所使用

​	![07](E:\笔记\UML语言用例图\07.png)

包含

​	多个用例的共通部分进行分离，用包含关系进行连接

​	![05](E:\笔记\UML语言用例图\05.png)

​	比如说用户需要取款，必须要调用登录验证，才能够进行取款，所以用例之间有==强制性==使用关系的，就叫包含关系

​	比如我要开车去进行短途旅行，路上没有油了，那么开车和加油就是包含关系

扩展

​	有条件有选择地被执行的用例

​	![06](E:\笔记\UML语言用例图\06.png)

​	比如usecase是输入用户名/密码登录，optional usecase是扫二维码登录，也就是说扫二维码登录是登录的一种扩展

用例和用例之间最主要的就是include和extend

![09](E:\笔记\UML语言用例图\09.png)

一般会员：可以租借录像带，要完成租借录像带一定要确认会员身份，但是可以支持银行卡支付

一般会员是VIP会员的父类，VIP继承了一般会员的功能，除此之外，VIP会员还可以通过快递租借录像带

###	用例描述

- 用例描述是对用例图的补充，用例描述和用例图合称为用例模型

  UseCase model 可详细描述用例内部的业务流程

​	避免仅靠用例图造成的误解

​	UML中没有明确规定用例图描述的标准格式，一般情况下包括

​	概要：用几行文字描述用例的作用，目的等

​	场景（脚本）：描述一个用例在某种条件下的具体执行流程

​	事件流：描述用例在各种条件下的具体流程

​	场景和事件流

- 场景用一段文字来描述用例执行时的具体流程。分为：

​	基本场景：正常运行能到达用例目的的场景

​	例外场景：出现异常情况不能达到用例目的的场景

- 事件流藐视用例在各种条件下的具体执行流程，一般包括：

​	前提条件：为使用例开始而必须满足的条件

​	事后条件：用例结束后对系统造成的影响

​	基本流：正常处理时的基本流程

​	代替流：出现概览低，但用例也还算是正常结束的流程

​	==例外流：发生错误时的流程==（通过这样的方式减轻负担，提高系统的健壮性）

![活动图](E:\笔记\UML语言用例图\活动图.png)

简单练习：

某销售公司准备开发一个订单管理系统

该公司的职员可以利用该订单系统进行订单的创建、删除和修改

请尝试用用例图描述该系统

请尝试用活动图描述创建订单用例的事件流

![订单用例图](E:\笔记\UML语言用例图\订单用例图.png)



![活动图1](E:\笔记\UML语言用例图\活动图1.png)

总结：

​	用例图：

​	用例图是在系统开发的初期阶段，描述站在用户的角度上看系统提供给用户的可使用的功能

​	参与者是与系统进行交互的角色，不是某个具体的个人。可以是人、硬件、或者外部已经存在的某个系统。共同点是要与系统有直接的信息交互

​	用例图和用例描述合称用例建模

​	活动图：

​	可用来表示业务流程，用例图中某个用例事件流，或者程序的算法描述

​	流程图也可以用活动图来取代

## 5.类图

​	类是着眼于现实中存在的事务（对象）的属性和行为的共同特征，并抽象后得到的

​	类图用来描述系统的静态结构和系统中类之间的静态关系

​	一个系统中，可以从不同侧面做出多个不同的类图，一个类图是描述系统静态结构的某个侧面的视图（view）

![类图的组成元素](E:\笔记\UML语言用例图\类图的组成元素.png)

**依赖关系：**

​	类D的方法中，需要实例化对象类c，则称为依赖关系

​	关联关系：结构关系，他们之间可能使用到对方

​					   关联关系最强的是结构型关系，类B由类D组合而成

**类的属性**：

​	在构成类的信息中，将知识性的静态信息称为属性

​		类生成的所有对象都拥有类中定义的属性

​		每个对象拥有独立的属性值

​		属性的表示方式：属性名：类型表示=初始值

**类的派生属性：**

​	通过其他属性计算得出的属性称为派生属性

​			属性名前加“/”来表示

​			虽然没有独立存在的必要性，在计算比较花事件，需要提高性能时可使用

**类的操作：**

​	在构成类的信息中，将行为（动态）信息称为操作

​		类生成的所有对象中都拥有类中定义的操作

​		可以针对该类的对象进行操作的调用

​	

​	表示方式：操作名（输入输出类别 参数名：类型=默认值）：返回值类型

​	输入输出类别：in（默认）、out、inout

​	多个参数的情况下，有逗号“，”隔开

​	输入输出类别，参数名，参数类型，默认值，返回值类型均可省略

![10](E:\笔记\UML语言用例图\10.png)

**可见性**

​	一个类的属性或者操作，能不能被其他类进行访问，称为可见性

​	在类图中可以为类的属性和操作指定可见性

​	【+】public 所有的类都可以访问

​	【-】 private只有自己可以访问

​	【#】protected只有自己及其子类可以访问

​	【~】package只有自己和同一包内的类可以访问

**类作用域**

​	类的所有对象能共享的属性值或者操作，称为类作用域属性或者类作用域操作

​	在==属性名或者操作名下画一条下划线==，或者在前面加上{static}以示标识

​	类作用域的属性值在该类的所有对象中共享

​	类作用域的操作是通过调用该类的操作来实现的

## 6.UML分析与设计案例

- 业务建模：认识业务本质

  业务建模，就是产品经理要知道你这个系统是要干什么？要解决什么问题？

  然后要描述，怎么去解决这个问题？

  

  某酒店可对外开放50个双人间和20个单人间

  周一至周五房价5折优惠，周六日全价

  旅客可以直接办理入住或提前预约，都需要登记个人信息

  预定房间需要定金，24小时之前可以免费取消，24小时之内不退定金

  先交付房费，再入住

  酒店经理需要查询每月的预定情况和入住情况的详细信息









- 用例建模：描述软件需求
- 用例分析：建立软件系统的分析模型
- 架构设计：设计系统的架构
- 构件设计：设计系统构建的实现细节
- 代码实现：将系统构件映射到目标语言上

